---
title: 'useParamsData (2)'
description: 'CRUD 데이터를 쉽게 관리해보자'
image: '/img/posts/custom.jpeg'
draft: false
category: 'project'
subImage: '/img/posts/project.png'
date: 2024-01-10 17:00:00
tags:
  - jotai
  - custom Hook
---



##  데이터 흐름

저번에 useParamsData 훅을 이용하여 데이터를 전역으로 관리하였습니다. 
Jotai에서는 전역으로 데이터를 사용할 수있도록 도와줍니다. 전역으로 사용한다는 것은 어디서든 데이터를 가져와서 사용할 수 있는 편리함을 제공합니다.
하지만 적절한 초기화를 해주지않으면 데이터 흐름에 방해를 줄 뿐만 아니라 필요없는 데이터가 전역에 배치되어 쓸대없는 메모리를 차지하게 될 것입니다. 이를 방지하기 위해 꼭 적절한 곳에서 필요한 데이터를 사용해야하고, 데이터를 다 사용하였다면 초기화를 해주어야할 것입니다. 한가지 예를 보겠습니다.



A / B라는 페이지에서 각각 useParams를 호출하여 사용한다고 가정하겠습니다. A페이지에서 data를 업데이트 시켜 params에 보관합니다. 사용자가 도중에 B페이지로 라우터 이동하게됩니다.
이때, A에 들어있는 params를 초기화하지 않고 이동시키기때문에 B페이지의 params는 A페이지에서 업데이트된 데이터를 담고있습니다. 
B페이지에서 데이터 바인딩이 오류가 날 것입니다. 이런 상황때문에, A페이지에서 벗어날 때, 초기화하는 것이 타당하겠죠.

`Page A (Params View) -> params updated -> params init -> Page B (Params View)`
이런식으로 말이죠.

그럼 초기화부분은 어디서 설정하면 좋을까요? 라우터 이동시 설정해주면 사용하는 곳마다 초기화설정을 따로안해주어도 되니 미들웨어에서 컨트롤하면 되겠다 생각했습니다. 
하지만 next.js에서는 SSG에서 미들웨어를 제공하지 않습니다. 음..난감합니다.
이렇게되면 사용하는 곳에서 useEffect를 제공하여 클린업 함수에서 처리해야하나 싶었습니다. 

 제가 커스텀훅에 처리하지 않고자하는 것은 초기화가 필요하지않은 곳도 있을겁니다. 커스텀 훅에 클린업시 초기화를 해버리면 이를 컨트롤하기 힘들어집니다. 
가능하면 커스텀훅엔 useEffect 초기설정외에 디펜던시 및 클린업함수를 사용하지않고자합니다. 
생명주기가 복잡해져 데이터 흐름을 읽기 힘들어질 수도 있다고 생각했습니다. 

## resetParams

```tsx
--- useParamsData ---
  
const updateParams = useSetAtom(paramsAtom)

const resetParams = () => {
    updateParams({})
}

---- page A ----
const {  resetParams } = useParamsData<AType>(initData)
useEffect(() => {
 return () => {
  resetParams()
 }
}, [])
```

결국, 사용하는 곳에서 초기화를 시키는 방법으로 사용하였습니다. 여기서 저는, 위에서 설명드렸던 것처럼 
`Page A (Params View) -> params updated -> params init -> Page B (Params View)` 이런 생명주기를 생각하고 테스트를 해봤습니다. 하지만 결과는 제가 생각하는 것과는 다르게 나왔습니다.

## Jotai에서 찾아보자

<img src="/img/project/console-3.png" width='600'/>

위의 콘솔로그를 보면, 페이지A에 있는 데이터가 페이지B에서도 여전히 콘솔로그로 찍히고있다. A에서 이미 클린업함수로 초기화를 시켰는데도 데이터흐름상, 클린업에서 초기화하는 것보다 store에서 pageB에서 view로 랜더링되는 시점이 더 빠른 것같다. 이 상태로 사용하면 데이터 B에서 view를 보여줄때 A에 있는 데이터를 보여줄 수 있으니 난감한 상황이었다. Jotai에서 랜더링되기전에 뭔가 이벤트를 발생할 수 있는게 있을까? 찾아보다가 공식문서가 너무 빈약하여 직접 문의하였다.

 <img src="/img/project/console-4.png" width='600'/>

<img src="/img/project/console-5.png" width='600'/>

이렇게 열심히 설명했지만 생각외로 답변은 심플하셨다.

<img src="/img/project/console-6.png" width='600'/>

<img src="/img/project/useHydrateAtoms.png" width='600'/>

페이지를 켜자마자 바로 SSR이라는 문구를 보고 다른방법을 강구하게 되었다.



## isParamsLoading

데이터를 직접 제어해야겠다는 생각을 했습니다.
`Page A (Params View) -> params updated -> params init -> -> initLoading (sucess)-> Page B (Params View)` 

loading이라는 주기를 추가하여 성공할때, Page B를 제공하게 되면 데이터가 서로 충돌 날 일이 없다고 판단했습니다.

```tsx
--- useParamsData --- 
 const [loading, setLoading] = useState(false) 
 const isParamsLoading = useMemo(() => {
   if (!loading) return true

   return loading && isEmpty(params)
 }, [initData, loading])

 useEffect(() => {
    if (initData) {
      setLoading(true)
      updateParams(initData)
    }
 }, [])

```

useParamsData 훅에서 initData가 있을시 두가지 액션을 합니다. 먼저, initData가 있다는 것은 사용하는 곳에서 초기설정을 원한다는 의미이고, 그에맞게 params에 초기값을 설정하고 싶다는 뜻입니다. initData가 없다는 의미는 초기설정은 이미 되어있고, 초기설정 한 params를 직접 사용하는 곳입니다. 그렇기 떄문에 따로 loading이 제공되지 않습니다. loading을 제공하는 시점은 초기세팅할 때만 필요하기 떄문입니다. 

다시 돌아가서, loading이 false일때는 isParamsLoading의 디폴트값으로 true로 설정해놓습니다. isParamsLoading의 디폴트를 true로 하는 이유는, 실제 loading이 시작되기전에는 isParamsLoading상태가 로딩상태어야 하기때문입니다. Loading flow가 일어나지 않았다는것은 아직 데이터가 주고받지 않았기 때문에 완료되지않은 상태입니다. 

이 때, 데이터흐름은 다음과 같습니다. 
`pageA InitSetting -> reset params(빈 값) -> pageB Init-> loading(true) && parmas 빈값 (로딩시작)-> updateParams에서 Params updated -> params에 initData저장 ->isParmasLoading(false) 로딩종료` 



## 데이터 흐름 파악하기

```tsx
--- Page A ---

const { params, resetParams, isParamsLoading } = useParamsData<NoticeAddParamsType>(initData)
  useEffect(() => {
    return () => {
      console.log('PageA Reset')
      resetParams()      
    }
  }, [])
  console.log('PageA isParamsLoading && params', isParamsLoading, params)

--- Page B ---
 const { params, resetParams, isParamsLoading } = useParamsData<DetailGuideAddParamsType>(initData)
  useEffect(() => {
    return () => {
      console.log('PageB Reset')
      resetParams()
    }
  }, [])
  console.log('PageB isParamsLoading && params', isParamsLoading, params)

--- useParamsData ---

  const isParamsLoading = useMemo(() => {
   console.log('loading && isEmpty && params', loading, isEmpty(params), params)
   if (!loading) return true
    return loading && isEmpty(params)
  }, [initData, loading])

  useEffect(() => {
    if (initData) {
      console.log('Init && params', params)
      setLoading(true)
      updateParams(initData)
    }
  }, [])
```

<img src="/img/project/useparams-4.png" width='600'/>

PageA에 접근하면 init Setting이 되고, 그 다음 pageB로 이동시 pageA에서 데이터를 리셋시킵니다. 
리셋시킴과 동시에 데이터는 빈값이 감지되어 isParamsLoading에서 콘솔를 보면 isEmpty는 true가 된상태입니다. 하지만 아직 loading이 시작되기전이므로  isParamsLoading은 로딩상태가 됩니다. 

 isParamsLoading은 로딩상태가 되며, 이 상태에서 Page B에서 Init setting을 시작하게됩니다.  `loading && isEmpty && params true false ` 콘솔을 보면, isEmpty가 false가 된것을 볼 수 있습니다. 
useEffect에서 params가 업데이트가 된 것을 알 수 있고, 실제로 params를 콘솔로 출력해보니, 빈 객체에서 데이터가 들어오는 것을 알 수있습니다. 데이터가 들어옴과 동시에 isParamsLoading은 false가됩니다.  정리해보면 다음과같습니다. 

`page A init Setting -> page B 이동 -> page A reset -> loading시작 전 빈객체 감지 -> page B init setting ->  loading 시작 -> params update -> page B Loading 끝`

결론적으로, `A -> B`로 이동시 A에 있는 데이터를 초기화시켜 이를 감지하는 loading을 만들어서 parmas에 데이터가 page B에 필요한 초기값으로 세팅 될때까지 기다리게하는 플로우라고 보시면 됩니다. 이렇게하면 `page A <-> page B`와의 데이터 충돌을 방지할 수 있습니다.
